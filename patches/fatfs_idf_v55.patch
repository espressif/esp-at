From 5302a4498e6f2567161577139ad06d7cf724b168 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Adam=20M=C3=BAdry?= <adam.mudry@espressif.com>
Date: Tue, 27 Jan 2026 04:27:01 +0100
Subject: [PATCH] fix: esp-at fatfs patches

---
 components/fatfs/fatfs_utils/utils.py   | 147 ++++++++--------
 components/fatfs/fatfsgen.py            | 225 +++++++++++++-----------
 components/fatfs/src/ff.c               |   8 +
 components/fatfs/vfs/esp_vfs_fat.h      |   9 +-
 components/fatfs/vfs/vfs_fat_spiflash.c |  62 ++++---
 components/fatfs/wl_fatfsgen.py         | 135 +++++++-------
 6 files changed, 326 insertions(+), 260 deletions(-)

diff --git a/components/fatfs/fatfs_utils/utils.py b/components/fatfs/fatfs_utils/utils.py
index 662586a50b6..4dd66b0718c 100644
--- a/components/fatfs/fatfs_utils/utils.py
+++ b/components/fatfs/fatfs_utils/utils.py
@@ -1,4 +1,4 @@
-# SPDX-FileCopyrightText: 2021-2024 Espressif Systems (Shanghai) CO LTD
+# SPDX-FileCopyrightText: 2021-2026 Espressif Systems (Shanghai) CO LTD
 # SPDX-License-Identifier: Apache-2.0
 import argparse
 import binascii
@@ -71,7 +71,9 @@ def number_of_clusters(number_of_sectors: int, sectors_per_cluster: int) -> int:
     return number_of_sectors // sectors_per_cluster
 
 
-def get_non_data_sectors_cnt(reserved_sectors_cnt: int, sectors_per_fat_cnt: int, fat_tables_cnt: int, root_dir_sectors_cnt: int) -> int:
+def get_non_data_sectors_cnt(
+    reserved_sectors_cnt: int, sectors_per_fat_cnt: int, fat_tables_cnt: int, root_dir_sectors_cnt: int
+) -> int:
     return reserved_sectors_cnt + sectors_per_fat_cnt * fat_tables_cnt + root_dir_sectors_cnt
 
 
@@ -90,7 +92,8 @@ def get_fat_sectors_count(clusters_count: int, sector_size: int) -> int:
     # number of byte halves
     cluster_s: int = fatfs_type_ // 4
     fat_size_bytes: int = (
-        clusters_count * 2 + cluster_s) if fatfs_type_ == FAT16 else (clusters_count * 3 + 1) // 2 + cluster_s
+        (clusters_count * 2 + cluster_s) if fatfs_type_ == FAT16 else (clusters_count * 3 + 1) // 2 + cluster_s
+    )
     return (fat_size_bytes + sector_size - 1) // sector_size
 
 
@@ -113,8 +116,10 @@ def right_strip_string(content: str, pad: int = PAD_CHAR) -> str:
 
 
 def build_lfn_short_entry_name(name: str, extension: str, order: int) -> str:
-    return '{}{}'.format(pad_string(content=name[:MAX_NAME_SIZE - 2] + '~' + chr(order), size=MAX_NAME_SIZE),
-                         pad_string(extension[:MAX_EXT_SIZE], size=MAX_EXT_SIZE))
+    return '{}{}'.format(
+        pad_string(content=name[: MAX_NAME_SIZE - 2] + '~' + chr(order), size=MAX_NAME_SIZE),
+        pad_string(extension[:MAX_EXT_SIZE], size=MAX_EXT_SIZE),
+    )
 
 
 def lfn_checksum(short_entry_name: str) -> int:
@@ -125,16 +130,14 @@ def lfn_checksum(short_entry_name: str) -> int:
     for i in range(MAX_NAME_SIZE + MAX_EXT_SIZE):
         # operation is a right rotation on 8 bits (Python equivalent for unsigned char in C)
         checksum_result = (0x80 if checksum_result & 1 else 0x00) + (checksum_result >> 1) + ord(short_entry_name[i])
-        checksum_result &= 0xff
+        checksum_result &= 0xFF
     return checksum_result
 
 
-def convert_to_utf16_and_pad(content: str,
-                             expected_size: int,
-                             pad: bytes = FULL_BYTE) -> bytes:
+def convert_to_utf16_and_pad(content: str, expected_size: int, pad: bytes = FULL_BYTE) -> bytes:
     # we need to get rid of the Byte order mark 0xfeff or 0xfffe, fatfs does not use it
     bom_utf16: bytes = b'\xfe\xff'
-    encoded_content_utf16: bytes = content.encode(LONG_NAMES_ENCODING)[len(bom_utf16):]
+    encoded_content_utf16: bytes = content.encode(LONG_NAMES_ENCODING)[len(bom_utf16) :]
     return encoded_content_utf16.ljust(2 * expected_size, pad)
 
 
@@ -149,7 +152,7 @@ def is_valid_fatfs_name(string: str) -> bool:
 
 def split_by_half_byte_12_bit_little_endian(value: int) -> Tuple[int, int, int]:
     value_as_bytes: bytes = Int16ul.build(value)
-    return value_as_bytes[0] & 0x0f, value_as_bytes[0] >> 4, value_as_bytes[1] & 0x0f
+    return value_as_bytes[0] & 0x0F, value_as_bytes[0] >> 4, value_as_bytes[1] & 0x0F
 
 
 def merge_by_half_byte_12_bit_little_endian(v1: int, v2: int, v3: int) -> int:
@@ -165,60 +168,68 @@ def split_content_into_sectors(content: bytes, sector_size: int) -> List[bytes]:
     clusters_cnt: int = required_clusters_count(cluster_size=sector_size, content=content)
 
     for i in range(clusters_cnt):
-        result.append(content[sector_size * i:(i + 1) * sector_size])
+        result.append(content[sector_size * i : (i + 1) * sector_size])
     return result
 
 
 def get_args_for_partition_generator(desc: str, wl: bool) -> argparse.Namespace:
     parser: argparse.ArgumentParser = argparse.ArgumentParser(description=desc)
-    parser.add_argument('input_directory',
-                        help='Path to the directory that will be encoded into fatfs image')
-    parser.add_argument('--output_file',
-                        default='fatfs_image.img',
-                        help='Filename of the generated fatfs image')
-    parser.add_argument('--partition_size',
-                        default=FATDefaults.SIZE,
-                        help='Size of the partition in bytes.' +
-                             ('' if wl else ' Use `--partition_size detect` for detecting the minimal partition size.')
-                        )
-    parser.add_argument('--sector_size',
-                        default=FATDefaults.SECTOR_SIZE,
-                        type=int,
-                        choices=ALLOWED_WL_SECTOR_SIZES if wl else ALLOWED_SECTOR_SIZES,
-                        help='Size of the partition in bytes')
-    parser.add_argument('--sectors_per_cluster',
-                        default=1,
-                        type=int,
-                        choices=ALLOWED_SECTORS_PER_CLUSTER,
-                        help='Number of sectors per cluster')
-    parser.add_argument('--root_entry_count',
-                        default=FATDefaults.ROOT_ENTRIES_COUNT,
-                        help='Number of entries in the root directory')
-    parser.add_argument('--long_name_support',
-                        action='store_true',
-                        help='Set flag to enable long names support.')
-    parser.add_argument('--use_default_datetime',
-                        action='store_true',
-                        help='For test purposes. If the flag is set the files are created with '
-                             'the default timestamp that is the 1st of January 1980')
-    parser.add_argument('--fat_type',
-                        default=0,
-                        type=int,
-                        choices=[FAT12, FAT16, 0],
-                        help="""
+    parser.add_argument('input_directory', help='Path to the directory that will be encoded into fatfs image')
+    parser.add_argument('--output_file', default='fatfs_image.img', help='Filename of the generated fatfs image')
+    parser.add_argument(
+        '--partition_size',
+        default=FATDefaults.SIZE,
+        help='Size of the partition in bytes.'
+        + ('' if wl else ' Use `--partition_size detect` for detecting the minimal partition size.'),
+    )
+    parser.add_argument(
+        '--sector_size',
+        default=FATDefaults.SECTOR_SIZE,
+        type=int,
+        choices=ALLOWED_WL_SECTOR_SIZES if wl else ALLOWED_SECTOR_SIZES,
+        help='Size of the partition in bytes',
+    )
+    parser.add_argument(
+        '--sectors_per_cluster',
+        default=1,
+        type=int,
+        choices=ALLOWED_SECTORS_PER_CLUSTER,
+        help='Number of sectors per cluster',
+    )
+    parser.add_argument(
+        '--root_entry_count', default=FATDefaults.ROOT_ENTRIES_COUNT, help='Number of entries in the root directory'
+    )
+    parser.add_argument('--long_name_support', action='store_true', help='Set flag to enable long names support.')
+    parser.add_argument(
+        '--use_default_datetime',
+        action='store_true',
+        help='For test purposes. If the flag is set the files are created with '
+        'the default timestamp that is the 1st of January 1980',
+    )
+    parser.add_argument(
+        '--fat_type',
+        default=0,
+        type=int,
+        choices=[FAT12, FAT16, 0],
+        help="""
                         Type of the FAT file-system. Select '12' for FAT12, '16' for FAT16.
                         Leave unset or select 0 for automatic file-system type detection.
-                        """)
-    parser.add_argument('--fat_count',
-                        default=FATDefaults.FAT_TABLES_COUNT,
-                        type=int,
-                        choices=[1, 2],
-                        help='Number of file allocation tables (FATs) in the filesystem.')
-    parser.add_argument('--wl_mode',
-                        default=None,
-                        type=str,
-                        choices=['safe', 'perf'],
-                        help='Wear levelling mode to use. Safe or performance. Only for sector size of 512')
+                        """,
+    )
+    parser.add_argument(
+        '--fat_count',
+        default=FATDefaults.FAT_TABLES_COUNT,
+        type=int,
+        choices=[1, 2],
+        help='Number of file allocation tables (FATs) in the filesystem.',
+    )
+    parser.add_argument(
+        '--wl_mode',
+        default=None,
+        type=str,
+        choices=['safe', 'perf'],
+        help='Wear levelling mode to use. Safe or performance. Only for sector size of 512',
+    )
 
     args = parser.parse_args()
     if args.fat_type == 0:
@@ -239,10 +250,7 @@ def read_filesystem(path: str) -> bytearray:
         return bytearray(fs_file.read())
 
 
-DATE_ENTRY = BitStruct(
-    'year' / BitsInteger(7),
-    'month' / BitsInteger(4),
-    'day' / BitsInteger(5))
+DATE_ENTRY = BitStruct('year' / BitsInteger(7), 'month' / BitsInteger(4), 'day' / BitsInteger(5))
 
 TIME_ENTRY = BitStruct(
     'hour' / BitsInteger(5),
@@ -282,9 +290,8 @@ def build_time_entry(hour: int, minute: int, sec: int) -> int:
     assert hour in range(FATFS_MAX_HOURS)
     assert minute in range(FATFS_MAX_MINUTES)
     assert sec in range(FATFS_MAX_SECONDS)
-    return int.from_bytes(TIME_ENTRY.build(
-        dict(hour=hour, minute=minute, second=sec // FATFS_SECONDS_GRANULARITY)),
-        byteorder='big'
+    return int.from_bytes(
+        TIME_ENTRY.build(dict(hour=hour, minute=minute, second=sec // FATFS_SECONDS_GRANULARITY)), byteorder='big'
     )
 
 
@@ -297,14 +304,16 @@ class FATDefaults:
     SECTOR_SIZE: int = 0x1000
     HIDDEN_SECTORS: int = 0
     ENTRY_SIZE: int = 32
-    NUM_HEADS: int = 0xff
+    NUM_HEADS: int = 0xFF
     OEM_NAME: str = 'MSDOS5.0'
-    SEC_PER_TRACK: int = 0x3f
+    SEC_PER_TRACK: int = 0x3F
     VOLUME_LABEL: str = 'Espressif'
     FILE_SYS_TYPE: str = 'FAT'
     ROOT_ENTRIES_COUNT: int = 512  # number of entries in the root directory, recommended 512
-    MEDIA_TYPE: int = 0xf8
-    SIGNATURE_WORD: bytes = b'\x55\xAA'
+    FAT12_MAX_ROOT_ENTRIES: int = 224  # maximum number of entries in FAT12 root directory
+    FAT16_MAX_ROOT_ENTRIES: int = 512  # maximum number of entries in FAT16 root directory
+    MEDIA_TYPE: int = 0xF8
+    SIGNATURE_WORD: bytes = b'\x55\xaa'
 
     # wear levelling defaults
     VERSION: int = 2
diff --git a/components/fatfs/fatfsgen.py b/components/fatfs/fatfsgen.py
index 30d274f5260..39e05ace2aa 100755
--- a/components/fatfs/fatfsgen.py
+++ b/components/fatfs/fatfsgen.py
@@ -1,5 +1,5 @@
 #!/usr/bin/env python
-# SPDX-FileCopyrightText: 2021-2024 Espressif Systems (Shanghai) CO LTD
+# SPDX-FileCopyrightText: 2021-2026 Espressif Systems (Shanghai) CO LTD
 # SPDX-License-Identifier: Apache-2.0
 import os
 from datetime import datetime
@@ -14,15 +14,15 @@ from fatfs_utils.fatfs_state import FATFSState
 from fatfs_utils.fs_object import Directory
 from fatfs_utils.long_filename_utils import get_required_lfn_entries_count
 from fatfs_utils.utils import BYTES_PER_DIRECTORY_ENTRY
-from fatfs_utils.utils import FATDefaults
 from fatfs_utils.utils import FATFS_INCEPTION
 from fatfs_utils.utils import FATFS_MIN_ALLOC_UNIT
+from fatfs_utils.utils import RESERVED_CLUSTERS_COUNT
+from fatfs_utils.utils import FATDefaults
 from fatfs_utils.utils import get_args_for_partition_generator
 from fatfs_utils.utils import get_fat_sectors_count
 from fatfs_utils.utils import get_non_data_sectors_cnt
 from fatfs_utils.utils import read_filesystem
 from fatfs_utils.utils import required_clusters_count
-from fatfs_utils.utils import RESERVED_CLUSTERS_COUNT
 
 
 def duplicate_fat_decorator(func):  # type: ignore
@@ -30,6 +30,7 @@ def duplicate_fat_decorator(func):  # type: ignore
         func(self, *args, **kwargs)
         if isinstance(self, FATFS):
             self.duplicate_fat()
+
     return wrapper
 
 
@@ -39,68 +40,76 @@ class FATFS:
     It contains reference to the FAT table and to the root directory.
     """
 
-    def __init__(self,
-                 binary_image_path: Optional[str] = None,
-                 size: int = FATDefaults.SIZE,
-                 reserved_sectors_cnt: int = FATDefaults.RESERVED_SECTORS_COUNT,
-                 fat_tables_cnt: int = FATDefaults.FAT_TABLES_COUNT,
-                 sectors_per_cluster: int = FATDefaults.SECTORS_PER_CLUSTER,
-                 sector_size: int = FATDefaults.SECTOR_SIZE,
-                 hidden_sectors: int = FATDefaults.HIDDEN_SECTORS,
-                 long_names_enabled: bool = False,
-                 use_default_datetime: bool = True,
-                 num_heads: int = FATDefaults.NUM_HEADS,
-                 oem_name: str = FATDefaults.OEM_NAME,
-                 sec_per_track: int = FATDefaults.SEC_PER_TRACK,
-                 volume_label: str = FATDefaults.VOLUME_LABEL,
-                 file_sys_type: str = FATDefaults.FILE_SYS_TYPE,
-                 root_entry_count: int = FATDefaults.ROOT_ENTRIES_COUNT,
-                 explicit_fat_type: Optional[int] = None,
-                 media_type: int = FATDefaults.MEDIA_TYPE) -> None:
-        # root directory bytes should be aligned by sector size
-        assert (int(root_entry_count) * BYTES_PER_DIRECTORY_ENTRY) % sector_size == 0
+    def __init__(
+        self,
+        binary_image_path: Optional[str] = None,
+        size: int = FATDefaults.SIZE,
+        reserved_sectors_cnt: int = FATDefaults.RESERVED_SECTORS_COUNT,
+        fat_tables_cnt: int = FATDefaults.FAT_TABLES_COUNT,
+        sectors_per_cluster: int = FATDefaults.SECTORS_PER_CLUSTER,
+        sector_size: int = FATDefaults.SECTOR_SIZE,
+        hidden_sectors: int = FATDefaults.HIDDEN_SECTORS,
+        long_names_enabled: bool = False,
+        use_default_datetime: bool = True,
+        num_heads: int = FATDefaults.NUM_HEADS,
+        oem_name: str = FATDefaults.OEM_NAME,
+        sec_per_track: int = FATDefaults.SEC_PER_TRACK,
+        volume_label: str = FATDefaults.VOLUME_LABEL,
+        file_sys_type: str = FATDefaults.FILE_SYS_TYPE,
+        root_entry_count: int = FATDefaults.ROOT_ENTRIES_COUNT,
+        explicit_fat_type: Optional[int] = None,
+        media_type: int = FATDefaults.MEDIA_TYPE,
+    ) -> None:
         # number of bytes in the root dir must be even multiple of BPB_BytsPerSec
-        if (int(root_entry_count) > 128):
+        if int(root_entry_count) > 128:
             assert ((int(root_entry_count) * BYTES_PER_DIRECTORY_ENTRY) // sector_size) % 2 == 0
 
         root_dir_sectors_cnt: int = (int(root_entry_count) * BYTES_PER_DIRECTORY_ENTRY) // sector_size
 
-        self.state: FATFSState = FATFSState(sector_size=sector_size,
-                                            explicit_fat_type=explicit_fat_type,
-                                            reserved_sectors_cnt=reserved_sectors_cnt,
-                                            root_dir_sectors_cnt=root_dir_sectors_cnt,
-                                            size=size,
-                                            file_sys_type=file_sys_type,
-                                            num_heads=num_heads,
-                                            fat_tables_cnt=fat_tables_cnt,
-                                            sectors_per_cluster=sectors_per_cluster,
-                                            media_type=media_type,
-                                            hidden_sectors=hidden_sectors,
-                                            sec_per_track=sec_per_track,
-                                            long_names_enabled=long_names_enabled,
-                                            volume_label=volume_label,
-                                            oem_name=oem_name,
-                                            use_default_datetime=use_default_datetime)
+        self.state: FATFSState = FATFSState(
+            sector_size=sector_size,
+            explicit_fat_type=explicit_fat_type,
+            reserved_sectors_cnt=reserved_sectors_cnt,
+            root_dir_sectors_cnt=root_dir_sectors_cnt,
+            size=size,
+            file_sys_type=file_sys_type,
+            num_heads=num_heads,
+            fat_tables_cnt=fat_tables_cnt,
+            sectors_per_cluster=sectors_per_cluster,
+            media_type=media_type,
+            hidden_sectors=hidden_sectors,
+            sec_per_track=sec_per_track,
+            long_names_enabled=long_names_enabled,
+            volume_label=volume_label,
+            oem_name=oem_name,
+            use_default_datetime=use_default_datetime,
+        )
         binary_image: bytes = bytearray(
-            read_filesystem(binary_image_path) if binary_image_path else self.create_empty_fatfs())
+            read_filesystem(binary_image_path) if binary_image_path else self.create_empty_fatfs()
+        )
         self.state.binary_image = binary_image
 
         self.fat: FAT = FAT(boot_sector_state=self.state.boot_sector_state, init_=True)
 
         root_dir_size = self.state.boot_sector_state.root_dir_sectors_cnt * self.state.boot_sector_state.sector_size
-        self.root_directory: Directory = Directory(name='A',  # the name is not important, must be string
-                                                   size=root_dir_size,
-                                                   fat=self.fat,
-                                                   cluster=self.fat.clusters[1],
-                                                   fatfs_state=self.state)
+        self.root_directory: Directory = Directory(
+            name='A',  # the name is not important, must be string
+            size=root_dir_size,
+            fat=self.fat,
+            cluster=self.fat.clusters[1],
+            fatfs_state=self.state,
+        )
         self.root_directory.init_directory()
 
     @duplicate_fat_decorator
-    def create_file(self, name: str,
-                    extension: str = '',
-                    path_from_root: Optional[List[str]] = None,
-                    object_timestamp_: datetime = FATFS_INCEPTION,
-                    is_empty: bool = False) -> None:
+    def create_file(
+        self,
+        name: str,
+        extension: str = '',
+        path_from_root: Optional[List[str]] = None,
+        object_timestamp_: datetime = FATFS_INCEPTION,
+        is_empty: bool = False,
+    ) -> None:
         """
         This method allocates necessary clusters and creates a new file record in the directory required.
         The directory must exists.
@@ -113,16 +122,18 @@ class FATFS:
         :param object_timestamp_: is not None, this will be propagated to the file's entry
         :param is_empty: True if there is no need to allocate any cluster, otherwise False
         """
-        self.root_directory.new_file(name=name,
-                                     extension=extension,
-                                     path_from_root=path_from_root,
-                                     object_timestamp_=object_timestamp_,
-                                     is_empty=is_empty)
+        self.root_directory.new_file(
+            name=name,
+            extension=extension,
+            path_from_root=path_from_root,
+            object_timestamp_=object_timestamp_,
+            is_empty=is_empty,
+        )
 
     @duplicate_fat_decorator
-    def create_directory(self, name: str,
-                         path_from_root: Optional[List[str]] = None,
-                         object_timestamp_: datetime = FATFS_INCEPTION) -> None:
+    def create_directory(
+        self, name: str, path_from_root: Optional[List[str]] = None, object_timestamp_: datetime = FATFS_INCEPTION
+    ) -> None:
         """
         Initially recursively finds a parent of the new directory
         and then create a new directory inside the parent.
@@ -139,10 +150,9 @@ class FATFS:
         if path_from_root:
             parent_dir = self.root_directory.recursive_search(path_from_root, self.root_directory)
 
-        self.root_directory.new_directory(name=name,
-                                          parent=parent_dir,
-                                          path_from_root=path_from_root,
-                                          object_timestamp_=object_timestamp_)
+        self.root_directory.new_directory(
+            name=name, parent=parent_dir, path_from_root=path_from_root, object_timestamp_=object_timestamp_
+        )
 
     @duplicate_fat_decorator
     def write_content(self, path_from_root: List[str], content: bytes) -> None:
@@ -165,8 +175,8 @@ class FATFS:
             fat_start = boot_sec_st.reserved_sectors_cnt * boot_sec_st.sector_size
             fat_end = fat_start + boot_sec_st.sectors_per_fat_cnt * boot_sec_st.sector_size
             second_fat_shift = boot_sec_st.sectors_per_fat_cnt * boot_sec_st.sector_size
-            self.state.binary_image[fat_start + second_fat_shift: fat_end + second_fat_shift] = (
-                self.state.binary_image[fat_start: fat_end]
+            self.state.binary_image[fat_start + second_fat_shift : fat_end + second_fat_shift] = (
+                self.state.binary_image[fat_start:fat_end]
             )
 
     def write_filesystem(self, output_path: str) -> None:
@@ -174,10 +184,9 @@ class FATFS:
             output.write(bytearray(self.state.binary_image))
 
     @duplicate_fat_decorator
-    def _generate_partition_from_folder(self,
-                                        folder_relative_path: str,
-                                        folder_path: str = '',
-                                        is_dir: bool = False) -> None:
+    def _generate_partition_from_folder(
+        self, folder_relative_path: str, folder_path: str = '', is_dir: bool = False
+    ) -> None:
         """
         Given path to folder and folder name recursively encodes folder into binary image.
         Used by method generate.
@@ -196,17 +205,19 @@ class FATFS:
                 content = file.read()
             file_name, extension = os.path.splitext(split_path[-1])
             extension = extension[1:]  # remove the dot from the extension
-            self.create_file(name=file_name,
-                             extension=extension,
-                             path_from_root=split_path[1:-1] or None,
-                             object_timestamp_=object_timestamp,
-                             is_empty=len(content) == 0)
+            self.create_file(
+                name=file_name,
+                extension=extension,
+                path_from_root=split_path[1:-1] or None,
+                object_timestamp_=object_timestamp,
+                is_empty=len(content) == 0,
+            )
             self.write_content(split_path[1:], content)
         elif os.path.isdir(real_path):
             if not is_dir:
-                self.create_directory(name=split_path[-1],
-                                      path_from_root=split_path[1:-1],
-                                      object_timestamp_=object_timestamp)
+                self.create_directory(
+                    name=split_path[-1], path_from_root=split_path[1:-1], object_timestamp_=object_timestamp
+                )
 
             # sorting files for better testability
             dir_content = list(sorted(os.listdir(real_path)))
@@ -221,11 +232,9 @@ class FATFS:
         self._generate_partition_from_folder(folder_name, folder_path=path_to_folder, is_dir=True)
 
 
-def calculate_min_space(path: List[str],
-                        fs_entity: str,
-                        sector_size: int = 0x1000,
-                        long_file_names: bool = False,
-                        is_root: bool = False) -> int:
+def calculate_min_space(
+    path: List[str], fs_entity: str, sector_size: int = 0x1000, long_file_names: bool = False, is_root: bool = False
+) -> int:
     if os.path.isfile(os.path.join(*path, fs_entity)):
         with open(os.path.join(*path, fs_entity), 'rb') as file_:
             content = file_.read()
@@ -251,26 +260,44 @@ def calculate_min_space(path: List[str],
 def main() -> None:
     args = get_args_for_partition_generator('Create a FAT filesystem and populate it with directory content', wl=False)
 
+    # 0 == default (512 items)
+    root_dir_count = args.root_entry_count
+    if root_dir_count == 0:
+        root_dir_count = FATDefaults.ROOT_ENTRIES_COUNT
+
+    # apply de-facto limits based on FAT type
+    if args.fat_type == 12:
+        if root_dir_count > FATDefaults.FAT12_MAX_ROOT_ENTRIES:
+            root_dir_count = FATDefaults.FAT12_MAX_ROOT_ENTRIES
+
+    if args.fat_type == 16:
+        if root_dir_count > FATDefaults.FAT16_MAX_ROOT_ENTRIES:
+            root_dir_count = FATDefaults.FAT16_MAX_ROOT_ENTRIES
+
     if args.partition_size == -1:
         clusters = calculate_min_space([], args.input_directory, args.sector_size, long_file_names=True, is_root=True)
         fats = get_fat_sectors_count(clusters, args.sector_size)
-        root_dir_sectors = (FATDefaults.ROOT_ENTRIES_COUNT * FATDefaults.ENTRY_SIZE) // args.sector_size
-        args.partition_size = max(FATFS_MIN_ALLOC_UNIT * args.sector_size,
-                                  (clusters + fats + get_non_data_sectors_cnt(RESERVED_CLUSTERS_COUNT,
-                                                                              fats,
-                                                                              args.fat_count,
-                                                                              root_dir_sectors)
-                                   ) * args.sector_size
-                                  )
-
-    fatfs = FATFS(size=args.partition_size,
-                  fat_tables_cnt=args.fat_count,
-                  sectors_per_cluster=args.sectors_per_cluster,
-                  sector_size=args.sector_size,
-                  long_names_enabled=args.long_name_support,
-                  use_default_datetime=args.use_default_datetime,
-                  root_entry_count=args.root_entry_count,
-                  explicit_fat_type=args.fat_type)
+        root_dir_sectors = max((root_dir_count * FATDefaults.ENTRY_SIZE // args.sector_size), 1)
+        args.partition_size = max(
+            FATFS_MIN_ALLOC_UNIT * args.sector_size,
+            (
+                clusters
+                + fats
+                + get_non_data_sectors_cnt(RESERVED_CLUSTERS_COUNT, fats, args.fat_count, root_dir_sectors)
+            )
+            * args.sector_size,
+        )
+
+    fatfs = FATFS(
+        size=args.partition_size,
+        fat_tables_cnt=args.fat_count,
+        sectors_per_cluster=args.sectors_per_cluster,
+        sector_size=args.sector_size,
+        long_names_enabled=args.long_name_support,
+        use_default_datetime=args.use_default_datetime,
+        root_entry_count=root_dir_count,
+        explicit_fat_type=args.fat_type,
+    )
 
     fatfs.generate(args.input_directory)
     fatfs.write_filesystem(args.output_file)
diff --git a/components/fatfs/src/ff.c b/components/fatfs/src/ff.c
index 3c3f1ace61d..dca543beef1 100644
--- a/components/fatfs/src/ff.c
+++ b/components/fatfs/src/ff.c
@@ -6298,6 +6298,14 @@ FRESULT f_mkfs (
 			}
 			if (fsty == FS_FAT12 && n_clst > MAX_FAT12) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters for FAT12 */
 
+			/* deploy de-facto rootdir limits given for FAT12 and FAT16 */
+			if (fsty == FS_FAT12) {
+				if (n_root > 224) n_root = 224;
+			}
+			else if (fsty == FS_FAT16) {
+				if (n_root > 512) n_root = 512;
+			}
+
 			/* Ok, it is the valid cluster configuration */
 			break;
 		} while (1);
diff --git a/components/fatfs/vfs/esp_vfs_fat.h b/components/fatfs/vfs/esp_vfs_fat.h
index 7b87818fa87..c2f42f84212 100644
--- a/components/fatfs/vfs/esp_vfs_fat.h
+++ b/components/fatfs/vfs/esp_vfs_fat.h
@@ -1,5 +1,5 @@
 /*
- * SPDX-FileCopyrightText: 2015-2024 Espressif Systems (Shanghai) CO LTD
+ * SPDX-FileCopyrightText: 2015-2026 Espressif Systems (Shanghai) CO LTD
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -111,6 +111,12 @@ typedef struct {
      * may be different.
      */
     bool use_one_fat;
+    /**
+     * Number of reserved root directory items.
+     * Effective only on FAT12/16, ignored on other file systems (by FatFS lib).
+     * 0 == default (maximum number of 32B entries given by the sector size).
+     */
+    size_t rootdir_entries;
 } esp_vfs_fat_mount_config_t;
 
 #define VFS_FAT_MOUNT_DEFAULT_CONFIG() \
@@ -120,6 +126,7 @@ typedef struct {
         .allocation_unit_size = 0, \
         .disk_status_check_enable = false, \
         .use_one_fat = false, \
+        .rootdir_entries = 0, \
     }
 
 // Compatibility definition
diff --git a/components/fatfs/vfs/vfs_fat_spiflash.c b/components/fatfs/vfs/vfs_fat_spiflash.c
index 0ee00e25d77..46fe5909b42 100644
--- a/components/fatfs/vfs/vfs_fat_spiflash.c
+++ b/components/fatfs/vfs/vfs_fat_spiflash.c
@@ -1,5 +1,5 @@
 /*
- * SPDX-FileCopyrightText: 2015-2025 Espressif Systems (Shanghai) CO LTD
+ * SPDX-FileCopyrightText: 2015-2026 Espressif Systems (Shanghai) CO LTD
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -25,7 +25,7 @@ static vfs_fat_spiflash_ctx_t *s_ctx[FF_VOLUMES] = {};
 
 extern esp_err_t esp_vfs_set_readonly_flag(const char* base_path); // from vfs/vfs.c to set readonly flag in esp_vfs_t struct externally
 
-static bool s_get_context_id_by_label(const char *label, uint32_t *out_id)
+static bool get_context_id_by_label(const char *label, uint32_t *out_id)
 {
     vfs_fat_spiflash_ctx_t *p_ctx = NULL;
     for (int i = 0; i < FF_VOLUMES; i++) {
@@ -44,7 +44,7 @@ static bool s_get_context_id_by_label(const char *label, uint32_t *out_id)
     return false;
 }
 
-static bool s_get_context_id_by_wl_handle(wl_handle_t wlhandle, uint32_t *out_id)
+static bool get_context_id_by_wl_handle(wl_handle_t wlhandle, uint32_t *out_id)
 {
     vfs_fat_spiflash_ctx_t *p_ctx = NULL;
     for (int i = 0; i < FF_VOLUMES; i++) {
@@ -59,7 +59,7 @@ static bool s_get_context_id_by_wl_handle(wl_handle_t wlhandle, uint32_t *out_id
     return false;
 }
 
-static uint32_t s_get_unused_context_id(void)
+static uint32_t get_unused_context_id(void)
 {
     for (uint32_t i = 0; i < FF_VOLUMES; i++) {
         if (!s_ctx[i]) {
@@ -72,13 +72,13 @@ static uint32_t s_get_unused_context_id(void)
 vfs_fat_spiflash_ctx_t* get_vfs_fat_spiflash_ctx(wl_handle_t wlhandle)
 {
     uint32_t id = FF_VOLUMES;
-    if (s_get_context_id_by_wl_handle(wlhandle, &id)) {
+    if (get_context_id_by_wl_handle(wlhandle, &id)) {
         return s_ctx[id];
     }
     return NULL;
 }
 
-static esp_err_t s_f_mount_rw(FATFS *fs, const char *drv, const esp_vfs_fat_mount_config_t *mount_config, vfs_fat_x_ctx_flags_t *out_flags, size_t sec_num)
+static esp_err_t f_mount_rw(FATFS *fs, const char *drv, const esp_vfs_fat_mount_config_t *mount_config, vfs_fat_x_ctx_flags_t *out_flags)
 {
     FRESULT fresult = f_mount(fs, drv, 1);
     if (fresult == FR_OK) {
@@ -121,14 +121,17 @@ static esp_err_t s_f_mount_rw(FATFS *fs, const char *drv, const esp_vfs_fat_moun
 
     size_t alloc_unit_size = esp_vfs_fat_get_allocation_unit_size(CONFIG_WL_SECTOR_SIZE, mount_config->allocation_unit_size);
     ESP_LOGI(TAG, "Formatting FATFS partition, allocation unit size=%d", alloc_unit_size);
-    UINT root_dir_entries;
-    if (CONFIG_WL_SECTOR_SIZE == 512) {
-        root_dir_entries = 16;
-    } else {
-        root_dir_entries = 128;
+
+    //if root directory entries set as default, allocate whole 1 sector for this purpose (one rootdir entry == 32B)
+    UINT root_dir_entries = mount_config->rootdir_entries;
+    if (root_dir_entries == 0) {
+        root_dir_entries = CONFIG_WL_SECTOR_SIZE / 32;
     }
-    const MKFS_PARM opt = {(BYTE)(FM_ANY | FM_SFD), (mount_config->use_one_fat ? 1 : 2), 0, (sec_num <= MIN_REQ_SEC ? root_dir_entries : 0), alloc_unit_size};
+    const MKFS_PARM opt = {(BYTE)(FM_ANY | FM_SFD), (mount_config->use_one_fat ? 1 : 2), 0, root_dir_entries, alloc_unit_size};
+    ESP_LOGD(TAG, "f_mkfs() params:  root_dir_entries: %ul, alloc_unit_size=%ul", root_dir_entries, alloc_unit_size);
+
     fresult = f_mkfs(drv, &opt, workbuf, workbuf_size);
+
     free(workbuf);
     workbuf = NULL;
     ESP_RETURN_ON_FALSE(fresult == FR_OK, ESP_FAIL, TAG, "f_mkfs failed (%d)", fresult);
@@ -152,11 +155,9 @@ esp_err_t esp_vfs_fat_spiflash_mount_rw_wl(const char* base_path,
     esp_err_t ret = ESP_OK;
     vfs_fat_spiflash_ctx_t *ctx = NULL;
     uint32_t ctx_id = FF_VOLUMES;
+    esp_partition_subtype_t subtype = partition_label ? ESP_PARTITION_SUBTYPE_ANY : ESP_PARTITION_SUBTYPE_DATA_FAT;
 
-    esp_partition_subtype_t subtype = partition_label ?
-            ESP_PARTITION_SUBTYPE_ANY : ESP_PARTITION_SUBTYPE_DATA_FAT;
-    const esp_partition_t *data_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA,
-                                                subtype, partition_label);
+    const esp_partition_t *data_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, subtype, partition_label);
     ESP_RETURN_ON_FALSE(data_partition, ESP_ERR_NOT_FOUND, TAG, "Failed to find FATFS partition (type='data', subtype='fat', partition_label='%s'). Check the partition table.", partition_label);
 
     ESP_RETURN_ON_ERROR(wl_mount(data_partition, wl_handle), TAG, "failed to mount wear levelling layer. ret = %i", ret);
@@ -187,9 +188,8 @@ esp_err_t esp_vfs_fat_spiflash_mount_rw_wl(const char* base_path,
 
     vfs_fat_x_ctx_flags_t flags = 0;
 
-    size_t sec_num = wl_size(*wl_handle) / wl_sector_size(*wl_handle);
     // Try to mount partition
-    ret = s_f_mount_rw(fs, drv, mount_config, &flags, sec_num);
+    ret = f_mount_rw(fs, drv, mount_config, &flags);
     if (ret != ESP_OK) {
         goto fail;
     }
@@ -203,7 +203,7 @@ esp_err_t esp_vfs_fat_spiflash_mount_rw_wl(const char* base_path,
     ctx->wlhandle = *wl_handle;
     ctx->flags = flags;
     memcpy(&ctx->mount_config, mount_config, sizeof(esp_vfs_fat_mount_config_t));
-    ctx_id = s_get_unused_context_id();
+    ctx_id = get_unused_context_id();
     //At this stage, we should always get a free context, otherwise program should return already
     assert(ctx_id != FF_VOLUMES);
     s_ctx[ctx_id] = ctx;
@@ -227,7 +227,7 @@ esp_err_t esp_vfs_fat_spiflash_unmount_rw_wl(const char* base_path, wl_handle_t
     ESP_RETURN_ON_FALSE(pdrv != 0xff, ESP_ERR_INVALID_STATE, TAG, "partition isn't registered, call esp_vfs_fat_spiflash_mount_rw_wl first");
 
     uint32_t id = FF_VOLUMES;
-    ESP_RETURN_ON_FALSE(s_get_context_id_by_wl_handle(wl_handle, &id), ESP_ERR_INVALID_STATE, TAG, "partition isn't registered, call esp_vfs_fat_spiflash_mount_rw_wl first");
+    ESP_RETURN_ON_FALSE(get_context_id_by_wl_handle(wl_handle, &id), ESP_ERR_INVALID_STATE, TAG, "partition isn't registered, call esp_vfs_fat_spiflash_mount_rw_wl first");
     //At this stage, as the wl_handle is valid, we should always get its context id, otherwise program should return already
     assert(id != FF_VOLUMES);
 
@@ -255,9 +255,8 @@ esp_err_t esp_vfs_fat_spiflash_format_cfg_rw_wl(const char* base_path, const cha
 
     wl_handle_t temp_handle = WL_INVALID_HANDLE;
     uint32_t id = FF_VOLUMES;
-    size_t sec_num = 0;
 
-    bool found = s_get_context_id_by_label(partition_label, &id);
+    bool found = get_context_id_by_label(partition_label, &id);
     if (!found) {
         esp_vfs_fat_mount_config_t default_mount_config = {
             .max_files = 1,
@@ -270,8 +269,7 @@ esp_err_t esp_vfs_fat_spiflash_format_cfg_rw_wl(const char* base_path, const cha
             mount_cfg = &default_mount_config;
         }
         ESP_RETURN_ON_ERROR(esp_vfs_fat_spiflash_mount_rw_wl(base_path, partition_label, mount_cfg, &temp_handle), TAG, "Failed to mount");
-        found = s_get_context_id_by_label(partition_label, &id);
-        sec_num = wl_size(temp_handle) / wl_sector_size(temp_handle);
+        found = get_context_id_by_label(partition_label, &id);
         assert(found);
         if (s_ctx[id]->flags & FORMATTED_DURING_LAST_MOUNT) {
             ESP_LOGD(TAG, "partition was formatted during mounting, skipping another format");
@@ -284,7 +282,6 @@ esp_err_t esp_vfs_fat_spiflash_format_cfg_rw_wl(const char* base_path, const cha
             s_ctx[id]->mount_config = *cfg;
         }
         temp_handle = s_ctx[id]->wlhandle;
-        sec_num = wl_size(temp_handle) / wl_sector_size(temp_handle);
     }
 
     //unmount
@@ -301,13 +298,14 @@ esp_err_t esp_vfs_fat_spiflash_format_cfg_rw_wl(const char* base_path, const cha
     }
     size_t alloc_unit_size = esp_vfs_fat_get_allocation_unit_size(CONFIG_WL_SECTOR_SIZE, s_ctx[id]->mount_config.allocation_unit_size);
     ESP_LOGI(TAG, "Formatting FATFS partition, allocation unit size=%d", alloc_unit_size);
-    UINT root_dir_entries;
-    if (CONFIG_WL_SECTOR_SIZE == 512) {
-        root_dir_entries = 16;
-    } else {
-        root_dir_entries = 128;
+
+    //if root directory entries set as default, allocate whole 1 sector for this purpose (one rootdir entry == 32B)
+    UINT root_dir_entries = s_ctx[id]->mount_config.rootdir_entries;
+    if (root_dir_entries == 0) {
+        root_dir_entries = CONFIG_WL_SECTOR_SIZE / 32;
     }
-    const MKFS_PARM opt = {(BYTE)(FM_ANY | FM_SFD), (s_ctx[id]->mount_config.use_one_fat ? 1 : 2), 0, (sec_num <= MIN_REQ_SEC ? root_dir_entries : 0), alloc_unit_size};
+    const MKFS_PARM opt = {(BYTE)(FM_ANY | FM_SFD), (s_ctx[id]->mount_config.use_one_fat ? 1 : 2), 0, root_dir_entries, alloc_unit_size};
+
     fresult = f_mkfs(drv, &opt, workbuf, workbuf_size);
     free(workbuf);
     workbuf = NULL;
@@ -315,7 +313,7 @@ esp_err_t esp_vfs_fat_spiflash_format_cfg_rw_wl(const char* base_path, const cha
 
 mount_back:
     if (partition_was_mounted) {
-        esp_err_t err = s_f_mount_rw(s_ctx[id]->fs, drv, &s_ctx[id]->mount_config, NULL, sec_num);
+        esp_err_t err = f_mount_rw(s_ctx[id]->fs, drv, &s_ctx[id]->mount_config, NULL);
         if (err != ESP_OK) {
             ESP_LOGE(TAG, "failed to mount back, go to recycle");
             goto recycle;
diff --git a/components/fatfs/wl_fatfsgen.py b/components/fatfs/wl_fatfsgen.py
index 13ef51689b9..29cc3b65506 100755
--- a/components/fatfs/wl_fatfsgen.py
+++ b/components/fatfs/wl_fatfsgen.py
@@ -1,5 +1,5 @@
 #!/usr/bin/env python
-# SPDX-FileCopyrightText: 2021-2024 Espressif Systems (Shanghai) CO LTD
+# SPDX-FileCopyrightText: 2021-2026 Espressif Systems (Shanghai) CO LTD
 # SPDX-License-Identifier: Apache-2.0
 from typing import Optional
 
@@ -7,12 +7,12 @@ from construct import Const
 from construct import Int32ul
 from construct import Struct
 from fatfs_utils.exceptions import WLNotInitialized
-from fatfs_utils.utils import crc32
-from fatfs_utils.utils import FATDefaults
 from fatfs_utils.utils import FULL_BYTE
+from fatfs_utils.utils import UINT32_MAX
+from fatfs_utils.utils import FATDefaults
+from fatfs_utils.utils import crc32
 from fatfs_utils.utils import generate_4bytes_random
 from fatfs_utils.utils import get_args_for_partition_generator
-from fatfs_utils.utils import UINT32_MAX
 from fatfsgen import FATFS
 
 
@@ -22,32 +22,33 @@ def remove_wl(binary_image: bytes) -> bytes:
     wl_state_size: int = WLFATFS.WL_STATE_HEADER_SIZE + WLFATFS.WL_STATE_RECORD_SIZE * total_sectors
     wl_state_sectors_cnt: int = (wl_state_size + FATDefaults.WL_SECTOR_SIZE - 1) // FATDefaults.WL_SECTOR_SIZE
     wl_state_total_size: int = wl_state_sectors_cnt * FATDefaults.WL_SECTOR_SIZE
-    wl_sectors_size: int = (wl_state_sectors_cnt
-                            * FATDefaults.WL_SECTOR_SIZE
-                            * WLFATFS.WL_STATE_COPY_COUNT
-                            + FATDefaults.WL_SECTOR_SIZE)
+    wl_sectors_size: int = (
+        wl_state_sectors_cnt * FATDefaults.WL_SECTOR_SIZE * WLFATFS.WL_STATE_COPY_COUNT + FATDefaults.WL_SECTOR_SIZE
+    )
 
     correct_wl_configuration = binary_image[-wl_sectors_size:]
 
-    data_ = WLFATFS.WL_STATE_T_DATA.parse(correct_wl_configuration[:WLFATFS.WL_STATE_HEADER_SIZE])
+    data_ = WLFATFS.WL_STATE_T_DATA.parse(correct_wl_configuration[: WLFATFS.WL_STATE_HEADER_SIZE])
 
     total_records = 0
     # iterating over records field of the first copy of the state sector
     for i in range(WLFATFS.WL_STATE_HEADER_SIZE, wl_state_total_size, WLFATFS.WL_STATE_RECORD_SIZE):
-        if correct_wl_configuration[i:i + WLFATFS.WL_STATE_RECORD_SIZE] != WLFATFS.WL_STATE_RECORD_SIZE * b'\xff':
+        if correct_wl_configuration[i : i + WLFATFS.WL_STATE_RECORD_SIZE] != WLFATFS.WL_STATE_RECORD_SIZE * b'\xff':
             total_records += 1
         else:
             break
-    before_dummy = binary_image[:total_records * FATDefaults.WL_SECTOR_SIZE]
-    after_dummy = binary_image[total_records * FATDefaults.WL_SECTOR_SIZE + FATDefaults.WL_SECTOR_SIZE:]
+    before_dummy = binary_image[: total_records * FATDefaults.WL_SECTOR_SIZE]
+    after_dummy = binary_image[total_records * FATDefaults.WL_SECTOR_SIZE + FATDefaults.WL_SECTOR_SIZE :]
     new_image: bytes = before_dummy + after_dummy
 
     # remove wl sectors
-    new_image = new_image[:len(new_image) - (FATDefaults.WL_SECTOR_SIZE + 2 * wl_state_total_size)]
+    new_image = new_image[: len(new_image) - (FATDefaults.WL_SECTOR_SIZE + 2 * wl_state_total_size)]
 
     # reorder to preserve original order
-    new_image = (new_image[-data_['move_count'] * FATDefaults.WL_SECTOR_SIZE:]
-                 + new_image[:-data_['move_count'] * FATDefaults.WL_SECTOR_SIZE])
+    new_image = (
+        new_image[-data_['move_count'] * FATDefaults.WL_SECTOR_SIZE :]
+        + new_image[: -data_['move_count'] * FATDefaults.WL_SECTOR_SIZE]
+    )
     return new_image
 
 
@@ -71,7 +72,7 @@ class WLFATFS:
         'block_size' / Int32ul,
         'version' / Int32ul,
         'device_id' / Int32ul,
-        'reserved' / Const(28 * b'\x00')
+        'reserved' / Const(28 * b'\x00'),
     )
 
     WL_CONFIG_T_DATA = Struct(
@@ -82,31 +83,33 @@ class WLFATFS:
         'updaterate' / Int32ul,
         'wr_size' / Int32ul,
         'version' / Int32ul,
-        'temp_buff_size' / Int32ul
+        'temp_buff_size' / Int32ul,
     )
     WL_CONFIG_T_HEADER_SIZE = 48
 
-    def __init__(self,
-                 size: int = FATDefaults.SIZE,
-                 sector_size: int = FATDefaults.SECTOR_SIZE,
-                 reserved_sectors_cnt: int = FATDefaults.RESERVED_SECTORS_COUNT,
-                 fat_tables_cnt: int = FATDefaults.FAT_TABLES_COUNT,
-                 sectors_per_cluster: int = FATDefaults.SECTORS_PER_CLUSTER,
-                 explicit_fat_type: int = None,
-                 hidden_sectors: int = FATDefaults.HIDDEN_SECTORS,
-                 long_names_enabled: bool = False,
-                 num_heads: int = FATDefaults.NUM_HEADS,
-                 oem_name: str = FATDefaults.OEM_NAME,
-                 sec_per_track: int = FATDefaults.SEC_PER_TRACK,
-                 volume_label: str = FATDefaults.VOLUME_LABEL,
-                 file_sys_type: str = FATDefaults.FILE_SYS_TYPE,
-                 use_default_datetime: bool = True,
-                 version: int = FATDefaults.VERSION,
-                 temp_buff_size: int = FATDefaults.TEMP_BUFFER_SIZE,
-                 device_id: int = None,
-                 root_entry_count: int = FATDefaults.ROOT_ENTRIES_COUNT,
-                 media_type: int = FATDefaults.MEDIA_TYPE,
-                 wl_mode: Optional[str] = None) -> None:
+    def __init__(
+        self,
+        size: int = FATDefaults.SIZE,
+        sector_size: int = FATDefaults.SECTOR_SIZE,
+        reserved_sectors_cnt: int = FATDefaults.RESERVED_SECTORS_COUNT,
+        fat_tables_cnt: int = FATDefaults.FAT_TABLES_COUNT,
+        sectors_per_cluster: int = FATDefaults.SECTORS_PER_CLUSTER,
+        explicit_fat_type: Optional[int] = None,
+        hidden_sectors: int = FATDefaults.HIDDEN_SECTORS,
+        long_names_enabled: bool = False,
+        num_heads: int = FATDefaults.NUM_HEADS,
+        oem_name: str = FATDefaults.OEM_NAME,
+        sec_per_track: int = FATDefaults.SEC_PER_TRACK,
+        volume_label: str = FATDefaults.VOLUME_LABEL,
+        file_sys_type: str = FATDefaults.FILE_SYS_TYPE,
+        use_default_datetime: bool = True,
+        version: int = FATDefaults.VERSION,
+        temp_buff_size: int = FATDefaults.TEMP_BUFFER_SIZE,
+        device_id: Optional[int] = None,
+        root_entry_count: int = FATDefaults.ROOT_ENTRIES_COUNT,
+        media_type: int = FATDefaults.MEDIA_TYPE,
+        wl_mode: Optional[str] = None,
+    ) -> None:
         self._initialized = False
         self._version = version
         self._temp_buff_size = temp_buff_size
@@ -119,14 +122,17 @@ class WLFATFS:
         # determine the number of required sectors (roundup to sector size)
         self.wl_state_sectors = (self.wl_state_size + FATDefaults.WL_SECTOR_SIZE - 1) // FATDefaults.WL_SECTOR_SIZE
 
-        self.boot_sector_start = FATDefaults.WL_SECTOR_SIZE  # shift by one "dummy" sector
-        self.fat_table_start = self.boot_sector_start + reserved_sectors_cnt * FATDefaults.WL_SECTOR_SIZE
-
-        wl_sectors = (WLFATFS.WL_DUMMY_SECTORS_COUNT + WLFATFS.WL_CFG_SECTORS_COUNT +
-                      self.wl_state_sectors * WLFATFS.WL_STATE_COPY_COUNT)
+        wl_sectors = (
+            WLFATFS.WL_DUMMY_SECTORS_COUNT
+            + WLFATFS.WL_CFG_SECTORS_COUNT
+            + self.wl_state_sectors * WLFATFS.WL_STATE_COPY_COUNT
+        )
         if self.wl_mode is not None and self.wl_mode == 'safe':
             wl_sectors += WLFATFS.WL_SAFE_MODE_DUMP_SECTORS
 
+        self.boot_sector_start = FATDefaults.WL_SECTOR_SIZE  # shift by one "dummy" sector
+        self.fat_table_start = self.boot_sector_start + reserved_sectors_cnt * FATDefaults.WL_SECTOR_SIZE
+
         self.plain_fat_sectors = self.total_sectors - wl_sectors
         self.plain_fatfs = FATFS(
             explicit_fat_type=explicit_fat_type,
@@ -144,7 +150,7 @@ class WLFATFS:
             sec_per_track=sec_per_track,
             volume_label=volume_label,
             file_sys_type=file_sys_type,
-            media_type=media_type
+            media_type=media_type,
         )
 
         self.fatfs_binary_image = self.plain_fatfs.state.binary_image
@@ -170,7 +176,7 @@ class WLFATFS:
                 updaterate=FATDefaults.UPDATE_RATE,
                 wr_size=FATDefaults.WR_SIZE,
                 version=self._version,
-                temp_buff_size=self._temp_buff_size
+                temp_buff_size=self._temp_buff_size,
             )
         )
 
@@ -180,14 +186,17 @@ class WLFATFS:
         # adding three 4 byte zeros to align the structure
         wl_config = wl_config_data + wl_config_crc + Int32ul.build(0) + Int32ul.build(0) + Int32ul.build(0)
 
-        self.fatfs_binary_image += (
-            wl_config + (FATDefaults.WL_SECTOR_SIZE - WLFATFS.WL_CONFIG_HEADER_SIZE) * FULL_BYTE)
+        self.fatfs_binary_image += wl_config + (FATDefaults.WL_SECTOR_SIZE - WLFATFS.WL_CONFIG_HEADER_SIZE) * FULL_BYTE
 
     def _add_state_sectors(self) -> None:
         wl_state_data = WLFATFS.WL_STATE_T_DATA.build(
             dict(
                 pos=0,
-                max_pos=self.plain_fat_sectors + WLFATFS.WL_DUMMY_SECTORS_COUNT,
+                max_pos=(
+                    self.plain_fat_sectors
+                    + WLFATFS.WL_DUMMY_SECTORS_COUNT
+                    + (WLFATFS.WL_SAFE_MODE_DUMP_SECTORS if self.wl_mode == 'safe' else 0)
+                ),
                 move_count=0,
                 access_count=0,
                 max_count=FATDefaults.UPDATE_RATE,
@@ -200,10 +209,16 @@ class WLFATFS:
         wl_state_crc = Int32ul.build(crc)
         wl_state = wl_state_data + wl_state_crc
         wl_state_sector_padding: bytes = (FATDefaults.WL_SECTOR_SIZE - WLFATFS.WL_STATE_HEADER_SIZE) * FULL_BYTE
-        wl_state_sector: bytes = (
+        wl_state_sectors: bytes = (
             wl_state + wl_state_sector_padding + (self.wl_state_sectors - 1) * FATDefaults.WL_SECTOR_SIZE * FULL_BYTE
         )
-        self.fatfs_binary_image += (WLFATFS.WL_STATE_COPY_COUNT * wl_state_sector)
+
+        # add 2 extra state-preservation sectors in 'Safe' mode
+        if self.wl_mode is not None and self.wl_mode == 'safe':
+            wl_safe_dummy_sec: bytes = WLFATFS.WL_SAFE_MODE_DUMP_SECTORS * FATDefaults.WL_SECTOR_SIZE * FULL_BYTE
+            self.fatfs_binary_image += wl_safe_dummy_sec
+
+        self.fatfs_binary_image += WLFATFS.WL_STATE_COPY_COUNT * wl_state_sectors
 
     def wl_write_filesystem(self, output_path: str) -> None:
         if not self._initialized:
@@ -215,15 +230,17 @@ class WLFATFS:
 if __name__ == '__main__':
     desc = 'Create a FAT filesystem with support for wear levelling and populate it with directory content'
     args = get_args_for_partition_generator(desc, wl=True)
-    wl_fatfs = WLFATFS(size=args.partition_size,
-                       sector_size=args.sector_size,
-                       fat_tables_cnt=args.fat_count,
-                       sectors_per_cluster=args.sectors_per_cluster,
-                       explicit_fat_type=args.fat_type,
-                       long_names_enabled=args.long_name_support,
-                       use_default_datetime=args.use_default_datetime,
-                       root_entry_count=args.root_entry_count,
-                       wl_mode=args.wl_mode)
+    wl_fatfs = WLFATFS(
+        size=args.partition_size,
+        sector_size=args.sector_size,
+        fat_tables_cnt=args.fat_count,
+        sectors_per_cluster=args.sectors_per_cluster,
+        explicit_fat_type=args.fat_type,
+        long_names_enabled=args.long_name_support,
+        use_default_datetime=args.use_default_datetime,
+        root_entry_count=args.root_entry_count,
+        wl_mode=args.wl_mode,
+    )
 
     wl_fatfs.plain_fatfs.generate(args.input_directory)
     wl_fatfs.init_wl()
-- 
2.50.1 (Apple Git-155)

